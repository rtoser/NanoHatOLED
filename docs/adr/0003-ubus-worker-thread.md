# ADR 0003: 将 ubus 操作从按键路径解耦为后台工作线程

*   **状态**: 提议 (Proposed)
*   **日期**: 2026-01-04
*   **作者**: libo

## 1. 背景 (Context)

当前实现中，按键处理路径会直接调用 `ubus_service_action()` 和 `sys_status_update_services()`。
这些操作包含同步 `ubus_invoke()`，最长可阻塞数秒，导致：
- 按键响应卡顿（输入路径被阻塞）。
- UI 渲染节拍被拉长（主循环被迫等待）。
- 连续按键可能被合并或延迟处理。

需要一种方式在保持单线程 UI/节拍模型（见 ADR 0002）的前提下，将 ubus 的阻塞 I/O 移出按键路径。

## 2. 决策 (Decision)

采用**ubus 后台工作线程**，通过任务队列解耦阻塞调用：

### 核心组件

1. **任务队列 (action_queue)**  
   - 有界环形缓冲区，存放服务动作请求（服务名、动作、时间戳）。
   - 主线程为生产者，ubus 线程为消费者。
   - 默认容量 **32**，队列满时丢弃最旧任务并记录警告。

2. **结果队列 (result_queue)**  
   - 有界环形缓冲区，存放执行结果（服务名、动作、成功/失败、错误码）。
   - ubus 线程为生产者，主线程为消费者。
   - 默认容量 **32**，队列满时丢弃最旧结果并记录警告。

3. **线程同步**  
   - 使用 `pthread_mutex_t` + `pthread_cond_t`。
   - 主线程入队后 `pthread_cond_signal` 唤醒 ubus 线程。
   - 退出时 `pthread_cond_broadcast` 唤醒所有等待线程。

### 线程职责

- **主线程**  
  - 处理按键事件并将服务动作入队。  
  - 定时或事件驱动消费结果队列，更新状态并 `mark_dirty()`。  

- **ubus 线程**  
  - 持有 `ubus_context`，串行执行 `ubus_service_action()`。  
  - 将执行结果写入结果队列，唤醒主线程。  

## 3. 备选方案 (Alternatives)

1. **主线程延迟执行（无新线程）**  
   - 简单，但仍会阻塞主循环，按键延迟依旧存在。
2. **异步 ubus（`ubus_invoke_async` + poll）**  
   - 保持单线程，但实现复杂、侵入性大。
3. **全量 UI 多线程模型（ADR 0001）**  
   - 能解决问题，但引入更大范围并发复杂度。

## 4. 后果 (Consequences)

### 优势 (Pros)
1. 按键路径不再被 ubus 阻塞，响应更稳定。
2. 主循环节拍不被 I/O 拉长，渲染更流畅。
3. 责任隔离清晰：主线程处理 UI/事件，ubus 线程处理阻塞 I/O。

### 劣势 (Cons)
1. 引入额外线程与同步逻辑，复杂度上升。
2. 队列溢出时可能丢弃旧任务，需要监控与日志。
3. 需要定义结果回传与 UI 状态更新策略。

## 5. 实施要点 (Implementation Notes)

- 事件结构需包含：`service_name`、`action`、`timestamp`、`request_id`（可选）。
- 两个队列均为固定容量 **32**；溢出时丢弃最旧事件并记录警告计数。
- 主线程消费结果时更新 `sys_status` 并 `mark_dirty()`。
- ubus 线程持有并管理 `ubus_context`，避免跨线程共享。
- 退出时广播唤醒，确保两线程均能安全退出。

---
本 ADR 作为“解耦阻塞 ubus I/O”的实施依据，后续若整体迁移到完整多线程 UI 架构（ADR 0001），应相应更新或合并决策。
