# ADR 0002: 单线程节拍驱动主循环

*   **状态**: 已废弃 (Superseded by ADR 0005)
*   **日期**: 2025-01-04
*   **作者**: Libo
*   **说明**: 当前实现仍基于此方案，待 ADR 0005 实施后废弃

## 1. 背景 (Context)

现有版本采用单线程主循环处理按键、状态更新与 UI 渲染。为了在不引入多线程复杂度的前提下提升响应性与节拍稳定性，需要一套明确的“主循环节拍”策略，避免：
- 按键响应受制于固定 `poll` 超时
- UI 刷新节奏随 I/O 耗时漂移
- 空闲时无谓唤醒导致 CPU 占用上升

## 2. 决策 (Decision)

采用**单线程 + deadline 调度**的节拍框架：

1. 使用单调时钟（`CLOCK_MONOTONIC`）作为唯一时间源。
2. 为多类任务维护独立 deadline（帧渲染、状态刷新、服务刷新、菜单超时）。
3. `gpio_button_wait(timeout)` 的超时取所有 deadline 中的最小值。
4. 仅在 `dirty` 或动画进行中渲染；空闲时延后下一帧 deadline。
5. 渲染完成后用“推进式”更新 `next_frame_ms`，允许丢帧但避免节拍漂移。
6. `handle_button()` 只更新状态并置 `dirty`，避免在按键路径做 I/O。

## 3. 备选方案 (Alternatives)

- **双线程事件队列模型**（见 ADR 0001）：更高响应性，但引入并发与同步复杂度。
- **固定超时 `poll` + 每轮重绘**：实现简单，但空闲时 CPU 占用高且节拍不稳定。

## 4. 后果 (Consequences)

### 优势 (Pros)

1. 无需引入 `pthreads`、`timerfd` 等并发组件，复杂度低。
2. 按键响应与渲染节拍解耦，避免固定超时带来的“空闲 10Hz”限制。
3. 空闲时几乎不渲染，降低 CPU 与 I2C 负载。
4. 通过“推进式”帧调度避免节拍漂移。

### 劣势 (Cons)

1. 阻塞型动画或 I/O 仍会暂停主循环，影响按键响应。
2. 极短按键事件在长耗时渲染期间仍可能被合并。
3. 后续功能扩展（更复杂动画/异步任务）可能逼近单线程上限。

## 5. 实施要点 (Implementation Notes)

- `handle_button()` 仅更新状态与 `dirty`，不要触发渲染或 I/O。
- 动画尽量做成“逐帧推进”，避免一次性阻塞。
- 空闲时将 `next_frame_ms` 推远，仅由其它 deadline 唤醒。
- 关屏时清理动画状态，避免空转。
- ubus 阻塞 I/O 的解耦建议见 ADR 0003（后台工作线程）。

---
本 ADR 作为当前版本的实现依据，若未来切换到多线程事件队列模型，应更新或废弃本决策。
